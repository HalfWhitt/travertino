from abc import ABC, abstractproperty
from collections import defaultdict
from collections.abc import Mapping, Sequence
from warnings import filterwarnings, warn

from .colors import color
from .constants import BOTTOM, LEFT, RIGHT, TOP

# Make sure deprecation warnings are shown by default
filterwarnings("default", category=DeprecationWarning)


class ImmutableList:
    def __init__(self, iterable):
        self._data = [*iterable]

    def __getitem__(self, index):
        return self._data[index]

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        return iter(self._data)

    def __eq__(self, other):
        return self._data == other

    def __str__(self):
        return str(self._data)

    def __repr__(self):
        return repr(self._data)

    def __reversed__(self):
        return reversed(self._data)

    def index(self, value):
        return self._data.index(value)

    def count(self, value):
        return self._data.count(value)


Sequence.register(ImmutableList)


class Choices:
    "A class to define allowable data types for a property"

    def __init__(
        self,
        *constants,
        default=None,  # DEPRECATED
        string=False,
        integer=False,
        number=False,
        color=False,
    ):
        if default is not None:
            warn(
                "The `default` argument to Choices.__init__ is deprecated. "
                "Providing no initial value to a property using it is sufficient.",
                DeprecationWarning,
                stacklevel=2,
            )

        self.constants = set(constants)

        self.string = string
        self.integer = integer
        self.number = number
        self.color = color

        self._options = sorted(str(c).lower().replace("_", "-") for c in self.constants)
        if self.string:
            self._options.append("<string>")
        if self.integer:
            self._options.append("<integer>")
        if self.number:
            self._options.append("<number>")
        if self.color:
            self._options.append("<color>")

    def validate(self, value):
        if self.string:
            try:
                return value.strip()
            except AttributeError:
                pass
        if self.integer:
            try:
                return int(value)
            except (ValueError, TypeError):
                pass
        if self.number:
            try:
                return float(value)
            except (ValueError, TypeError):
                pass
        if self.color:
            try:
                return color(value)
            except ValueError:
                pass
        for const in self.constants:
            if value == const:
                return const

        raise ValueError(f"{value!r} is not a valid value")

    def __str__(self):
        return ", ".join(self._options)


class validated_property:
    def __init__(self, choices, initial=None):
        """Define a simple validated property attribute.

        :param choices: The available choices.
        :param initial: The initial value for the property.
        """
        self.choices = choices
        self.initial = None if initial is None else self.validate(initial)

    def __set_name__(self, owner, name):
        self.name = name
        owner._BASE_PROPERTIES[owner].add(name)
        owner._BASE_ALL_PROPERTIES[owner].add(name)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        value = getattr(obj, f"_{self.name}", None)
        return self.initial if value is None else value

    def __set__(self, obj, value):
        if value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        if value is None:
            raise ValueError(
                "Python `None` cannot be used as a style value; "
                f"to reset a property, use del `style.{self.name}`."
            )

        value = self.validate(value)

        if value != getattr(obj, f"_{self.name}", self.initial):
            setattr(obj, f"_{self.name}", value)
            obj.apply(self.name, value)

    def __delete__(self, obj):
        try:
            delattr(obj, f"_{self.name}")
        except AttributeError:
            pass
        else:
            obj.apply(self.name, self.initial)

    @property
    def _name_if_set(self):
        return f" {self.name}" if hasattr(self, "name") else ""

    def validate(self, value):
        try:
            return self.choices.validate(value)
        except ValueError:
            raise ValueError(
                f"Invalid value {value!r} for property{self._name_if_set}; "
                f"Valid values are: {self.choices}"
            )

    def is_set_on(self, obj):
        return hasattr(obj, f"_{self.name}")


class list_property(validated_property):
    def validate(self, value):
        if isinstance(value, str):
            value = [value]
        elif not isinstance(value, Sequence):
            raise TypeError(
                f"Value for list property{self._name_if_set} must be a sequence."
            )

        if not value:
            name = getattr(self, "name", "prop_name")
            raise ValueError(
                "List properties cannot be set to an empty sequence; "
                f"to reset a property, use del `style.{name}`."
            )

        # This could be a comprehension, but then the error couldn't specify which value
        # is at fault.
        result = []
        for item in value:
            try:
                item = self.choices.validate(item)
            except ValueError:
                raise ValueError(
                    f"Invalid item value {item!r} for list property{self._name_if_set}; "
                    f"Valid values are: {self.choices}"
                )
            result.append(item)

        return ImmutableList(result)


class property_alias(ABC):
    """A base class for list / composite properties."""

    def __set_name__(self, owner, name):
        self.name = name
        owner._BASE_ALL_PROPERTIES[owner].add(self.name)

    def __delete__(self, obj):
        for name in self.property_names:
            del obj[name]

    def is_set_on(self, obj):
        return any(hasattr(obj, name) for name in self.property_names)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        return tuple(obj[name] for name in self.property_names)

    @abstractproperty
    def __set__(self, obj, value): ...


class directional_property(property_alias):
    DIRECTIONS = [TOP, RIGHT, BOTTOM, LEFT]
    ASSIGNMENT_SCHEMES = {
        #   T  R  B  L
        1: [0, 0, 0, 0],
        2: [0, 1, 0, 1],
        3: [0, 1, 2, 1],
        4: [0, 1, 2, 3],
    }

    def __init__(self, name_format):
        """Define a property attribute that proxies for top/right/bottom/left alternatives.

        :param name_format: The format from which to generate subproperties. "{}" will
            be replaced with "_top", "_bottom", etc.
        """
        self.property_names = [
            name_format.format(f"_{direction}") for direction in self.DIRECTIONS
        ]

    def __set__(self, obj, value):
        if value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        if not isinstance(value, tuple):
            value = (value,)

        if order := self.ASSIGNMENT_SCHEMES.get(len(value)):
            for name, index in zip(self.property_names, order):
                obj[name] = value[index]
        else:
            raise ValueError(
                f"Invalid value for '{self.name}'; value must be a number, or a 1-4 tuple."
            )


class composite_property(property_alias):
    def __init__(self, optional, required, parse_str=str.split):
        """Define a property attribute that proxies for an arbitrary set of properties.

        :param optional: The names of aliased properties that are optional in
           assignment. Order is irrelevant, unless the same value is valid for more than
           one property; in that case, values are assigned by priority of which one coud
           apply to the fewest properties, and when that ties, they're assigned in
           order.
        :param required: Which properties, if any, are required when setting this
            property. In assignment, these must be specified last and in order.
        :param parse_str: A callable with which to parse a string into valid input.
        """
        self.optional = optional
        self.required = required
        self.property_names = self.optional + self.required
        self.min_num = len(self.required)
        self.max_num = len(self.required) + len(self.optional)
        self.parse_str = parse_str

    def __set__(self, obj, composite_value):
        if composite_value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        if isinstance(composite_value, str):
            composite_value = self.parse_str(composite_value)

        if not self.min_num <= len(composite_value) <= self.max_num:
            raise TypeError(
                f"Composite property {self.name} must be set with at least "
                f"{self.min_num} and no more than {self.max_num} values."
            )

        # Don't clear and set values until we're sure everything validates.
        staged = {}

        # Handle the required values first. They have to be there, and in order, or the
        # whole assignment is invalid.
        required_values = composite_value[-len(self.required) :]

        for name, value in zip(self.required, required_values):
            # Let error propagate if it raises.
            staged[name] = getattr(obj.__class__, name).validate(value)

        # Next, look through the optional values.
        optional_values = composite_value[: -len(self.required)]

        # For each value, determine which properties can accept it.
        values_with_valid_props = []
        for value in optional_values:
            valid_props = []
            for name in self.optional:
                try:
                    getattr(obj.__class__, name).validate(value)
                    valid_props.append(name)
                except ValueError:
                    pass
            if not valid_props:
                raise ValueError(
                    f"Value {value} not valid for any optional properties of composite "
                    f"property {self.name}"
                )

            values_with_valid_props.append((value, valid_props))

        # Then assign the values in order of specificity; that is, a value
        # gets "priority" if it matches fewer possible properties. (Values of equal
        # specificity are simply assigned to properties in order.)
        for value, valid_props in sorted(
            values_with_valid_props, key=lambda tup: len(tup[1])
        ):
            for name in valid_props:
                if name not in staged:
                    staged[name] = value
                    break
            else:
                # Didn't break; no valid property is still free.
                raise ValueError(
                    f"Value {value} not valid for any optional properties of composite "
                    f"property {self.name} that are not already being assigned."
                )

        # Apply staged properties, and clear any that haven't been staged.
        for name in self.optional:
            if name not in staged:
                del obj[name]
        obj |= staged


class BaseStyle:
    """A base class for style declarations.

    Exposes a dict-like interface. Designed for subclasses to be decorated
    with @dataclass(kw_only=True), which most IDEs should be able to interpret and
    provide autocompletion of argument names. On Python < 3.10, init=False can be used
    to still get the keyword-only behavior from the included __init__.
    """

    # Contains only "actual" properties
    _BASE_PROPERTIES = defaultdict(set)
    # Also includes property aliases
    _BASE_ALL_PROPERTIES = defaultdict(set)

    def __init_subclass__(cls):
        # Give the subclass a direct reference to its properties.
        cls._PROPERTIES = cls._BASE_PROPERTIES[cls]
        cls._ALL_PROPERTIES = cls._BASE_ALL_PROPERTIES[cls]

    # Fallback in case subclass isn't decorated as dataclass (probably from using
    # previous API) or for pre-3.10, before kw_only argument existed.
    def __init__(self, **properties):
        self.update(**properties)

    @property
    def _applicator(self):
        return getattr(self, "_assigned_applicator", None)

    @_applicator.setter
    def _applicator(self, value):
        self._assigned_applicator = value

        if value is not None:
            try:
                self.reapply()
            # This is backwards compatibility for Toga, which (at least as of
            # 0.4.8), assigns style and applicator before the widget's
            # implementation is available.
            except Exception:
                warn(
                    "Failed to apply style when assigning applicator, or when "
                    "assigning a new style once applicator is present. Node should be "
                    "sufficiently initialized to apply its style before it is assigned "
                    "an applicator. This will be an exception in a future version.",
                    RuntimeWarning,
                    stacklevel=2,
                )

    ######################################################################
    # Interface that style declarations must define
    ######################################################################

    def apply(self, property, value):
        raise NotImplementedError(
            "Style must define an apply method"
        )  # pragma: no cover

    ######################################################################
    # Provide a dict-like interface
    ######################################################################

    def reapply(self):
        for name in self._PROPERTIES:
            self.apply(name, self[name])

    def update(self, **properties):
        """Set multiple styles on the style definition."""
        for name, value in properties.items():
            name = name.replace("-", "_")
            if name not in self._ALL_PROPERTIES:
                raise NameError(f"Unknown style {name}")

            self[name] = value

    def copy(self, applicator=None):
        """Create a duplicate of this style declaration."""
        dup = self.__class__()
        dup.update(**self)

        if applicator is not None:
            warn(
                "Providing an applicator to BaseStyle.copy() is deprecated. Set "
                "applicator afterward on the returned copy.",
                DeprecationWarning,
                stacklevel=2,
            )
            dup._applicator = applicator

        return dup

    def __getitem__(self, name):
        name = name.replace("-", "_")
        if name in self._ALL_PROPERTIES:
            return getattr(self, name)
        raise KeyError(name)

    def __setitem__(self, name, value):
        name = name.replace("-", "_")
        if name in self._ALL_PROPERTIES:
            setattr(self, name, value)
        else:
            raise KeyError(name)

    def __delitem__(self, name):
        name = name.replace("-", "_")
        if name in self._ALL_PROPERTIES:
            delattr(self, name)
        else:
            raise KeyError(name)

    def keys(self):
        return {*self}

    def items(self):
        return [(name, self[name]) for name in self]

    def __len__(self):
        return sum(1 for _ in self)

    def __contains__(self, name):
        return name in self._ALL_PROPERTIES and (
            getattr(self.__class__, name).is_set_on(self)
        )

    def __iter__(self):
        yield from (name for name in self._PROPERTIES if name in self)

    def __or__(self, other):
        if isinstance(other, BaseStyle):
            if self.__class__ is not other.__class__:
                return NotImplemented
        elif not isinstance(other, Mapping):
            return NotImplemented

        result = self.copy()
        result.update(**other)
        return result

    def __ior__(self, other):
        if isinstance(other, BaseStyle):
            if self.__class__ is not other.__class__:
                return NotImplemented
        elif not isinstance(other, Mapping):
            return NotImplemented

        self.update(**other)
        return self

    ######################################################################
    # Get the rendered form of the style declaration
    ######################################################################

    def __str__(self):
        return "; ".join(
            f"{name.replace('_', '-')}: {value}" for name, value in sorted(self.items())
        )

    ######################################################################
    # Backwards compatibility
    ######################################################################

    @classmethod
    def validated_property(cls, name, choices, initial=None):
        warn(
            "Defining style properties with class methods is deprecated; use class "
            "attributes instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        prop = validated_property(choices, initial)
        setattr(cls, name, prop)
        prop.__set_name__(cls, name)

    @classmethod
    def directional_property(cls, name):
        warn(
            "Defining style properties with class methods is deprecated; use class "
            "attributes instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        name_format = name % "{}"
        name = name_format.format("")
        prop = directional_property(name_format)
        setattr(cls, name, prop)
        prop.__set_name__(cls, name)
